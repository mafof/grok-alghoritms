# Заметки
Если столкнулся со сложной задачей, и не знаешь как ее решить,
можно прибегнуть к стратегии "разделяй и властвуй", или методом
"динамического программирования".

Если понял что у задачи не существует эффективного решения, то можно
получить приблизительный ответ с использованием "жадного алгоритма"

## Логарифмы
Логарифм (операция, обратно возведению в степень) числа `B` по основанию числа `A` называют такую степень,
в которую надо возвести число `A`, что бы получить число `B`. Например:

```
log(a)b = c === a^c = b

log(2)32 = 5 === 5^2 = 32
```

P.S. В книге принято, что O(n) === log(2)n что в свою очередь равен O(log_2(n)), но на деле, Big O-notation
описывается далеко не так, как это сказано в книге.

## Big O-notation ([источник](https://habr.com/ru/post/444594/))
### O(1)
**O(1)** (сложность порядка 1 (order 1)/алгоритм выполняется за постоянное/константное время (constant time)) - 
Самое простое обозначение сложности алгоритма. Оно означает, что алгоритму требуется фиксированное кол-во операций.

Пример:
```javascript
const arr = [1,2,3,4,5];
console.log(arr[0]);
```

Для того что бы описать что этот алгоритм, имеет именно такую сложность, необходимо описать сложность через
количество операций, выполняемых для достижения результата, в зависимости от ввода (операций на ввод).

Другими словами: **насколько возрастет кол-во операций при увеличении кол-ва входных параметров.**

В нашем примере входных параметров 5, потому что в массиве 5 элементов. Для получения результата
нужно выполнить одну операцию (взять элемент по индексу). И несмотря на кол-во вводных параметров
для решения данной задачи нужна только одна операция.

***O(1)* - алгоритмы самые эффективные.**

**P.S.** - Нет никакой разницы какое число будет стоять после O (1,2,3 ...), т.к. это все равно будет означать
константную сложность (обычно всегда пишется O(1)). 

### O(n)
**O(n)** (сложность порядка n (order n)) - данная сложность гласит о том, что кол-во операций, прямо
пропорциональна кол-ву входных данных. такой тип алгоритмов называют "линейными",
или что алгоритм "линейно масштабируется". 

Пример:
```javascript
const nums = [1,2,3,4,5];
let sum = 0;
for(let num of nums) {
    sum += num;
}
```

В данном примере, кол-во операций, будет возрастать в зависимости от кол-во входных данных, т.к. необходимо
пройтись по всему массиву.

### O(n^2)
**O(n^2)** - Алгоритмы, с данной нотацией, являются менее эффективными, т.к. им приходиться выполнять n операций
по 2 раза.

Пример:
```javascript
const hasDuplicates = function (num) {
    //loop the list, our O(n) op
    for (let i = 0; i < nums.length; i++) {
        const thisNum = nums[i];
        //loop the list again, the O(n^2) op
        for (let j = 0; j < nums.length; j++) {
            //make sure we're not checking same number
            if (j !== i) {
                const otherNum = nums[j];
                //if there's an equal value, return
                if (otherNum === thisNum) return true;
            }
        }
    }
    //if we're here, no dups
    return false;
}
const nums = [1, 2, 3, 4, 5, 5];
hasDuplicates(nums);//true
```

В данном примере в функции реализации поиска значения, есть 2 цикла, что означает что мы 2 раза бегаем
по одному и тому же массиву.

Алгоритмы с вложенными циклами по той же коллекции всегда O(n^2).

### O(log n)
**O(log n)** - Данная сложность означает, что мы потратим log_2(n) операций, при выполнении задачи, что гораздо
быстрее чем O(n) и тем более O(n^2). Примером алгоритма с такой сложностью может выступать бинарный поиск.

[Примеры других обозначений сложности алгоритмов](https://en.wikipedia.org/wiki/Big_O_notation)

# Алгоритмы

## Бинарный поиск
Алгоритм ищет более быстрым способом значение в отсортированном массиве, постоянно отсекая лишние данные.
Например, при поиске числа от 0 до 100, алгоритм в начале запрашивает находиться ли число в диапазоне от 0 до 50
, и если число находиться в этом диапазоне, то алгоритм понимает что уже можно отсечь числа от 51, до 100,
и далее делит диапазон снова пополам.